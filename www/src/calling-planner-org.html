<!--
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../bower_components/polymer/polymer.html">
<link rel="import" href="shared-styles.html">
<script src="../js/test_data.js"></script>

<dom-module id="calling-planner-org">
  <template>
    <style include="shared-styles">
      :host {
        display: block;

        padding: 
        10px;
      }
      paper-card.rate { @apply(--layout-horizontal); }
      .rate-image {
        width: 200px;
        height: 170px;
        background: url('./donuts.jpg');
        background-size: cover;
      }
      .rate-content {
        @apply(--layout-flex);
        float: left;
      }
      .rate-header { @apply(--paper-font-headline); }
      .rate-name { color: var(--paper-grey-600); margin: 10px 0; }
      paper-icon-button.rate-icon {
        --iron-icon-fill-color: white;
        --iron-icon-stroke-color: var(--paper-grey-600);
      }
      .org {
        transition: box-shadow .5s;
        width: 200px;
        display: inline-block;
        margin: 8px;
        padding: 0px;
      }

      .org:hover {
        z-index:1000;
        box-shadow:rgba(0, 0, 0, 0.3) 0 16px 16px 0;
        -webkit-box-shadow:rgba(0, 0, 0, 0.3) 0 16px 16px 0;
        -moz-box-shadow:rgba(0, 0, 0, 0.3) 0 16px 16px 0;
      }

      .card_link {
        text-decoration: none;
      }

      .simple-list {
        background-color: #eee; 
        min-height: 50px;
        padding-left: 0;
        cursor: move;
      }

      .simple-list li {
        list-style-type: none;
        margin-left: 10px;
      }

      .simple-list .handle {
        cursor: move;
      }

      .simple-list .remove {
        cursor: pointer;
      }

    </style>

    <div id="content">

      <!-- <iron-selector selected="{{page}}" attr-for-selected="name" class="drawer-list"> -->
        <a name="brainstorm" href="/brainstorm/">Back to Organizations</a>
      <!-- </iron-selector> -->

      <template is="dom-repeat" items="{{groups}}">
        <div>
          <h1 id="{{item.orgTypeId}}">{{item.name}}</h1>
          <template is="dom-repeat" items="{{item.callingsInGroup}}" as="calling" index-as="calling_number">
            <div id="org" class="card">
              <h2 id="{{calling.callingTypeId}}">{{calling.callingTitle}}</h2>
                <ul class="simple-list">
                  <template is="dom-repeat" items ="{{calling.callingMembers}}" as="member" index-as="member_number">
                    <li><span id="{{member.individualId}}" class="{{member.positionName}}"></span><span id="-1" class="handle">::</span> {{member.preferredName}} <span class="remove">X</span></li>
                  </template>
                </ul>
            </div>
          </template>
        </div>
        <template is="dom-if" if="[[isEqual(index, groups.length)]]">
          <span foo="[[arrayChanged()]]"></span>
        </template>
      </template>
    </div>

    <!-- <script src="../bower_components/Sortable/Sortable.js"></script> -->
    
  </template>

  <script>

    Polymer({
      is: 'calling-planner-org',
      properties: {
        groups: {
          type: Array,
          notify: true,
          observer: 'arrayChanged'
        },
        orgId: {
          type: String,
          notify: true,
          reflectToAttribute: true,
          observer: 'idChanged'
        }
      },

      // Check if we are loading the last list element.
      isEqual: function (v1, v2) {
        // console.log(v1 === v2-1);
        return v1 === (v2-1);
      },

      idChanged: function() {
        var id = this.orgId;
        this.groups = this.getOrganization(json.callings, id);
      },

      arrayChanged: function () {
        var elements = Polymer.dom(this.root).querySelectorAll('.simple-list');

        elements.forEach(function (element) {

          Sortable.create(element, {
            // handle: ".handle", 
            group: "brainstorm",
            filter: ".remove",
            sort: true,
            onFilter: function (e) {

              var release_member = {
                member: window.people[e.item.firstChild.id],
                calling: window.callings[e.item.parentNode.parentNode.children[0].id]
              };

              // console.log(window.stagedObj)

              //if release is in window.staged then 
              // if(window.stagedObj[release_member.member.preferredName]) {
              //   console.log('cleared 1')
              //   for(var i =0; i < window.stagedObj[release_member.member.preferredName].length; i++) {
              //     console.log(window.stagedObj[release_member.member.preferredName][i] , release_member.calling.positionName)
              //     if(window.stagedObj[release_member.member.preferredName][i] === release_member.calling.positionName) { //if find calling match
              //       //remove from window.staged
              //       console.log('cleared 2')
              //       console.log(window.staged)
              //       for(var j = 0; j < window.staged.length; j++) {
              //         console.log(window.staged[j].member.preferredName , release_member.member.preferredName)
              //         console.log(window.staged[j].calling.positionName , release_member.calling.positionName)
              //         if(window.staged[j].member.preferredName === release_member.member.preferredName && window.staged[j].calling.positionName === release_member.calling.positionName ) {
              //           console.log('cleared 3')
              //           window.staged[i] = -1;

              //           var item = e.item;
              //           if (item.parentNode !== null) { item.parentNode.removeChild(item); }
              //           return null;
              //         }
              //       }
              //     }
              //   }
              // }
  
              // if (!window.releasedObj[release_member.member.preferredName]) {
              //   window.releasedObj[release_member.member.preferredName] = []
              window.released.push(release_member);
              // }
              // else {
              //   window.releasedObj[release_member.member.preferredName].push({ release_member.calling.positionName });
              // }
              
              // console.log(window.released);
              // console.log(window.releasedObj);

              var item = e.item;
              if (item.parentNode !== null) {
                item.parentNode.removeChild(item);
              }

            },

            onUpdate: function (evt) {
              // console.log('updated', evt);
            },

            onAdd: function (evt) {

              var stage_member = {
                member: window.people[evt.item.firstChild.id],
                calling: window.callings[evt.item.parentNode.parentNode.children[0].id]
              };

              // if (!window.stagedObj[stage_member.member.preferredName]) {
              //   window.stagedObj[stage_member.member.preferredName] = [stage_member.calling.positionName]
              //   window.staged.push(stage_member)
              // }
              // else {
              //   //see if calling is already brainstormed for this person
              //   for(var i = 0; i < window.stagedObj[stage_member.member.preferredName].length; i++) {
              //     if (window.stagedObj[stage_member.member.preferredName][i] !== stage_member.calling) {
              //       window.stagedObj[stage_member.member.preferredName].push(stage_member.calling.positionName);
                    window.staged.push(stage_member)
                  // }
              //   }
              // }
            },

            onRemove: function (evt) {
              console.log('removed', evt);
              console.warn('this action should be disabled');
            }

          });
        });
      },

      getOrganization : (json, id) => {
        // console.log(json[id]);
        if(json[id].hasRendered) {
          if(json[id].children) {
            return json[id].children;
          }
          else {
            return [json[id]];
          }
        }
        else {
          json[id].hasRendered = true;
        }

        let callingName = null;
        let callingsInGroupIndex = -1;
        // const orgId = window.location.pathname.split('/')[2]; 
        if(!id) return null;
        let org = json[id].children;
        // console.log(org)

        if (!org) {
          org = json[id];
          this.extractCallingsFromAssignmentsInGroup(null, org);
          // console.log(org);
          return [org]
        }
        else {
          let pizza = appendCallingGroupToObject(org);
          // console.log(pizza);
          return pizza;
        }
      },

    }); //end polymer declaration

    function appendCallingGroupToObject(org) {
      for(let i =0; i < org.length; i++) { //loop through sub-categories of calling-type
        extractCallingsFromAssignmentsInGroup(i,org);
      }
      return org;
    }

    function extractCallingsFromAssignmentsInGroup(i, org) {

      // console.log('i',i);
      // console.log('org',org);
      // console.log('orgi',org[i]);

      (i || i === 0) ? current_org = org[i] : current_org = org;
      if (current_org.children) {
        // console.log("found child")
        return appendCallingGroupToObject(current_org);
      }

      // console.log('current_org',current_org);
      for(let j = 0; j < current_org.assignmentsInGroup.length; j++) { //loop through each type of calling in sub-category
        if(!current_org.callingsInGroup) {
          current_org.callingsInGroup = [] //initialize or append to array of calling objects
          callingsInGroupIndex = -1;
          callingName = 'unreplicable calling name 7878';
        }
        if(current_org.assignmentsInGroup[j].positionName === callingName) { //if like the one before
          try {
            current_org.callingsInGroup[callingsInGroupIndex]['callingMembers'].push(window.people[current_org.assignmentsInGroup[j].individualId])
          }
          catch (e) {
            console.warn(e);
          }
          
        }
        else {
          callingName = current_org.assignmentsInGroup[j].positionName;
          let calling = {};
          calling['callingTitle'] = current_org.assignmentsInGroup[j].positionName;
          calling['callingTypeId'] = current_org.assignmentsInGroup[j].positionTypeId;
          calling['callingMembers'] = [];
          calling['callingMembers'].push(window.people[current_org.assignmentsInGroup[j].individualId]);
          current_org.callingsInGroup.push(calling);   //add calling object to array
          callingsInGroupIndex++;
        }
        // current_org.assignmentsInGroup[j].person = window.people[current_org.assignmentsInGroup[j].individualId].preferredName;
      }
      return null;
    }

  </script>
</dom-module>
